
<!doctype html>
<html lang="en">
    <head>
        <title>Conway Turbo</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link href='http://fonts.googleapis.com/css?family=Roboto+Slab:400,700,300,100' rel='stylesheet' type='text/css'>
        <style>
            *{
                box-sizing: border-box;
                font-family: 'Roboto Slab', sans-serif;
                font-size: 13px;
                font-weight: 100;
                margin :0;
                padding: 0;
            }
            html {
                height: 100%;
            }
            body {
                margin: 0;
                padding: 0;
                background-color: #000000;
                color: #ffffff;
                line-height: 20px;
                height: 100%;
                overflow: hidden;
                font-family: 'Roboto Slab', sans-serif;
                font-size: 13px;
                font-weight: 100;
            }
            #container {
                position: absolute;
                left: 0;
                top: 0;
                right: 0;
                bottom: 0;
            }
            .hidden{
                -webkit-transform: translate3d( 0, 300px, 0 );
                -moz-transform: translate3d( 0, 300px, 0 );
                -ms-transform: translate3d( 0, 300px, 0 );
                -o-transform: translate3d( 0, 300px, 0 );
                transform: translate3d( 0, 300px, 0 );
            }
        </style>
</head>
    <body>

        <div id="container"></div>
        
        <script src="libs/three.js"></script>
        <script src="libs/OrbitControls.js"></script>
        <script src="libs/AugmentedCompileShader.js"></script>
        <script src="libs/Maf.js"></script>
    <!--    <script src="Wagner/Wagner.js"></script>
        <script src="Wagner/Wagner.base.js"></script>-->

<script id="copy-fs" type="x-shader/x-vertex">

uniform sampler2D input;
varying vec2 vUv;

void main() {

    gl_FragColor = texture2D( input, vUv );

}

</script>

<script id="vertexShader" type="x-shader/x-vertex">

    precision mediump float;
    precision mediump int;

    attribute float boxIndex;
    attribute vec3 boxPosition;

    uniform mat4 modelViewMatrix; // optional
    uniform mat4 projectionMatrix; // optional
    uniform mat3 normalMatrix; // optional
    uniform vec3 cameraPosition;

    uniform vec2 dimensions;
    uniform float boxSize;
    uniform vec3 boxVertices[ 18 ];
    uniform vec3 boxNormals[ 3 ];
    uniform vec2 boxUVs[ 6 ];
    uniform float time;

    uniform sampler2D map;
    uniform sampler2D posMap;
    uniform sampler2D rotMap;

    varying vec3 vPosition;
    varying vec4 vColor;
    varying vec3 vEye;
    varying vec2 vN;
    varying vec2 vUv;

    float rand(vec2 co){
        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }

    mat4 rotationMatrix(vec3 axis, float angle)
    {
        axis = normalize(axis);
        float s = sin(angle);
        float c = cos(angle);
        float oc = 1.0 - c;
        
        return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                    0.0,                                0.0,                                0.0,                                1.0);
    }

    #define M_PI 3.1415926535897932384626433832795

    void main() {

        float i = floor( boxIndex / 18. );
        int vi = int( mod( boxIndex, 18. ) );
        float x = mod( i, dimensions.x );
        float y = mod( floor( i / dimensions.x ), dimensions.y );

        float u = x / ( dimensions.x - 1. );
        float v = y / ( dimensions.y - 1. );
        vUv = vec2( u, v );

        vec3 pos = texture2D( posMap, vUv ).rgb * 510.; //( .5 - texture2D( posMap, vUv ).rgb ) * 2000.;
        vec4 rot = texture2D( rotMap, vUv ).rgba;

       // pos = vec3( x, y, 0 ) * 2.;

        vUv = boxUVs[ int( mod( float( vi ), 6. ) ) ];
        vColor.rgb = vec3( vUv, 0. );

        float s = 1.;//texture2D( map, vUv ).r;
    
        int ni = vi / 6;
        vec3 n = boxNormals[ ni ];
        vec3 scale = vec3( 1. );//vec3( .75 * s * boxSize );

        float a = rot.a * 2. * M_PI + .1 * time;// s * M_PI + 1. * time * s;
        mat4 rm = rotationMatrix( vec3( 1. ), a );
        vec4 rn = rm * vec4( n, 1. );
        vec3 visPosition = pos + rn.xyz * scale;
        vec3 vVis = visPosition - cameraPosition;
        float d = dot( normalize( vVis ), normalize( rn.xyz ) );
        vec3 c = boxVertices[ vi ];
        if( d < 0. ) {
            c += 2. * n; // flip it!
        }
        vec3 nPosition = pos + ( rm * vec4( c, 1. ) ).xyz * scale;

        vec4 mVP = modelViewMatrix * vec4( nPosition, 1. );
        vPosition = mVP.xyz;
        gl_Position = projectionMatrix * mVP;

    }

</script>

<script id="fragmentShader" type="x-shader/x-fragment">
#extension GL_OES_standard_derivatives : enable

    precision mediump float;
    precision mediump int;

    uniform float drawColor;

    uniform float time;
    uniform sampler2D noiseMap;
    uniform sampler2D tMatCap;
    uniform sampler2D heightMap;
    uniform float size;
    uniform sampler2D texture;
    uniform sampler2D normalMap;

    uniform vec3 colors[ 3 ];

    varying vec2 vUv;
    varying vec3 vPosition;
    varying vec4 vColor;
    varying vec3 vEye;
    varying vec2 vN;

    float rand(vec2 co){
        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }

    mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv) {

        // get edge vectors of the pixel triangle
        vec3 dp1 = dFdx( p );
        vec3 dp2 = dFdy( p );
        vec2 duv1 = dFdx( uv );
        vec2 duv2 = dFdy( uv );
     
        // solve the linear system
        vec3 dp2perp = cross( dp2, N );
        vec3 dp1perp = cross( N, dp1 );
        vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
        vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
     
        // construct a scale-invariant frame 
        float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
        return mat3( T * invmax, B * invmax, N );
    }


    vec3 perturb_normal( vec3 N, vec3 V, vec2 texcoord ) {
        // assume N, the interpolated vertex normal and 
        // V, the view vector (vertex to eye)
        vec3 map = texture2D( normalMap, texcoord ).xyz;
        map = map * 255./127. - 128./127.;
        mat3 TBN = cotangent_frame(N, -V, texcoord);
        return normalize(TBN * map);
    }

    void main() {

        vec4 color;

        vec3 fdx = vec3(dFdx(vPosition.x),dFdx(vPosition.y),dFdx(vPosition.z));
        vec3 fdy = vec3(dFdy(vPosition.x),dFdy(vPosition.y),dFdy(vPosition.z));
        vec3 normal = normalize(cross(fdx,fdy));

        vec3 e = normalize( vPosition );
        vec3 n = perturb_normal( normal, e, vUv );
        vec3 r = reflect( e, n );
        float m = 2. * sqrt( pow( r.x, 2. ) + pow( r.y, 2. ) + pow( r.z + 1., 2. ) );
        vec2 vN = r.xy / m + .5;

        vec3 light = texture2D( tMatCap, vN ).rgb;
        vec3 base = texture2D( texture, vUv ).rgb;

        //gl_FragColor.rgb = .5 + .5 * normalize( normal );
        gl_FragColor.rgb = mix( base, base * ( .5 + .5 * light ), clamp( .4, 1., length( base ) ) );//mix( base, vColor.rgb, .5 );
        //gl_FragColor.rgb = vColor.rgb;
        //gl_FragColor.rgb = texture2D( texture, vUv ).rgb;
        //float z = 1.0 - (gl_FragCoord.z / gl_FragCoord.w) / 200.0;
        //gl_FragColor.rgb = vec3( vUv, 1. );

        gl_FragColor.a = 1.;
        //gl_FragColor= vec4( vUv, 0., 1. );
       // gl_FragColor = vec4( 1. );

    }

</script>

<script>

/*WAGNER.vertexShadersPath = 'Wagner/vertex-shaders';
WAGNER.fragmentShadersPath = 'Wagner/fragment-shaders';
WAGNER.assetsPath = 'Wagner/assets/';

var composer, conwayPass;*/

var loaded = true;

var camera, controls,
    scene, 
    renderer,
    container,
    mesh, ball;
    
var container = document.getElementById( 'container' ),
    progress = document.getElementById( 'progress' );
    message = document.getElementById( 'message' );
var material;

/*document.getElementById( 'aboutBtn' ).addEventListener( 'click', function( e ) { 
    document.getElementById( 'about' ).classList.add( 'visible' );
    e.preventDefault();
} );*/

/*function ConwayPass() {

    WAGNER.Pass.call( this );
    WAGNER.log( 'ConwayPass constructor' );
    this.loadShader( 'conway-fs.glsl' );

    this.params.input = null;

}

ConwayPass.prototype = Object.create( WAGNER.Pass.prototype );

ConwayPass.prototype.run = function( c ) {

    this.shader.uniforms.tInput.value = this.params.input;
    c.pass( this.shader );

}*/

var links = document.querySelectorAll( 'a[rel=external]' );
for( var j = 0; j < links.length; j++ ) {
    var a = links[ j ];
    a.addEventListener( 'click', function( e ) {
        window.open( this.href, '_blank' );
        e.preventDefault();
    }, false );
}

window.addEventListener( 'load', init );

function setProgress( p ) {

    progress.style.width = p + '%';

}

function showProgress( state ) {

    progress.classList.toggle( 'visible', state );

}

var mouse = { x: 0, y: 0 };
var meshes = [];

function init() {

    container = document.getElementById( 'container' );

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.target = new THREE.Vector3( 0, 0, 0 );
    camera.position.z = 30;
    scene.add( camera );

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    /*composer = new WAGNER.Composer( renderer, { useRGBA: false } );
    composer.setSize( gridWidth * gridHeight, gridDepth );
    
    conwayPass = new ConwayPass();*/

    container.appendChild( renderer.domElement );

    generateGeometry();
    buildScene();

}

var positions = [];

function generateGeometry() {

    var pos = new THREE.Vector3( .5, .5, .5 );
    var sizes = [ 1, 3, 5 ];
    var max = 4;
    for( var j = 0; j < 10; j++ ) {

        var size = sizes[ ~~( Math.random() * sizes.length ) ];

        var o = .5 * ( max - size );
        var xo = size + ~~( Math.random() * .5 * size );
        console.log( size, o );
        for( var z = 0; z < size; z++ ) {
            for( var y = 0; y < size; y++ ){
                for( var x = 0; x < xo; x++ ) {
                    var p = new THREE.Vector3();
                    p.copy( pos );
                    p.add( new THREE.Vector3( x, y + o, z + o ) );
                    positions.push( p )
                }
            }
        }
        pos.x += xo;
        
    }

/*    for( var y = 0; y < 20; y++ ) {
        for( var x = 0; x < 20; x++ ) {
            var p = new THREE.Vector3();
            p.copy( pos );
            p.add( new THREE.Vector3( x, y, 0 ) );
            positions.push( p )
        }
    } */
     
}

function buildScene( w ) {

    meshes.forEach( function( mesh ) {
        scene.remove( mesh );
    } );
    meshes = [];

    var s = 8;
    var l = Maf.nextPowerOfTwo( Math.sqrt( positions.length ) );
    var l = ~~( Math.sqrt( positions.length ) ) + 1;
    var width = l;
    var height = l;
    
    var geometry = new THREE.BufferGeometry();

    var triangles = width * height * 6;
    geometry.verticesToDraw = triangles * 9;

    var boxIndices = new THREE.BufferAttribute( new Float32Array( triangles * 3 * 1 ), 1 );

    for ( var i = 0; i < boxIndices.length; i ++ ) {
        boxIndices.setX( i, i );
    }

    geometry.addAttribute( 'boxIndex', boxIndices );

    var data = new Uint8Array( width * height * 4 );
    for( var j = 0; j < data.length; j++ ) {
        data[ j ] = j * 256 / data.length; //Math.random() * 256;
        data[ j ] = 50 + Math.random() * 216;
    }

    texture = new THREE.DataTexture( data, width, height, THREE.RGBAFormat )
    texture.needsUpdate = true;

    var data = new Uint8Array( width * height * 4 );
    var ptr = 0;
    var s = 30;
    for( var j = 0; j < data.length; j += 4 ) {
       var p = positions[ ptr ];
       data[ j ] = p.x;
       data[ j + 1 ] = p.y;
       data[ j + 2 ] = p.z;
       ptr++;
       ptr %= positions.length;
    }

    posTexture = new THREE.DataTexture( data, width, height, THREE.RGBAFormat )
    posTexture.minFilter = posTexture.magFilter = THREE.NearestFilter,
    posTexture.needsUpdate = true;

    var rotData = new Uint8Array( width * height * 4 );
    for( var j = 0; j < rotData.length; j += 4 ) {
       rotData[ j ] = Math.random() * 256;
       rotData[ j + 1 ] = Math.random() * 256;
       rotData[ j + 2 ] = Math.random() * 256;
       rotData[ j + 3 ] = Math.random() * 256;
    }

    rotTexture = new THREE.DataTexture( rotData, width, height, THREE.RGBAFormat )
    rotTexture.minFilter = rotTexture.magFilter = THREE.NearestFilter,
    rotTexture.needsUpdate = true;

    var plane = new THREE.Mesh( new THREE.PlaneGeometry( 10, 10 ), new THREE.MeshBasicMaterial( { map: posTexture } ) );
        scene.add( plane );

    //composer.reset();
    //conwayPass.params.input = texture;

    material = new THREE.RawShaderMaterial( {

        attributes: {
            boxIndex: { type: 'f', value: null }
        },
        uniforms: {
            map: { type: 't', value: texture },
            posMap: { type: 't', value: posTexture },
            rotMap: { type: 't', value: rotTexture },
            texture: { type: 't', value: THREE.ImageUtils.loadTexture( 'stripe.png' ) },
            normalMap: { type: 't', value: THREE.ImageUtils.loadTexture( 'stripe-normal.png' ) },
            tMatCap: { type: 't', value: THREE.ImageUtils.loadTexture( 'matcap2.jpg' ) },
            dimensions: { type: 'v2', value: new THREE.Vector3( width, height ) },
            boxSize: { type: 'f', value: 1 },
            boxVertices: { type: '3fv', value: [ 
                
                -1,-1,-1,
                -1,-1, 1,
                -1, 1, 1,
                
                -1,-1,-1,
                -1, 1, 1,
                -1, 1,-1,

                1, 1,-1,
                1,-1,-1,
                -1,-1,-1,

                1, 1,-1,
                -1,-1,-1,
                -1, 1,-1,

                1,-1, 1,
                -1,-1, 1,
                -1,-1,-1,

                1,-1, 1,
                -1,-1,-1,
                1,-1,-1,
    
            ] },
            boxNormals: { type: '3fv', value: [

                1, 0, 0,
                0, 0, 1,
                0, 1, 0

            ] },
            boxUVs: { type: '2fv', value: [

                0, 0,
                0, 1,
                1, 1,

                0, 0,
                1, 1,
                1, 0

            ] },
            time: { type: 'f', value: 0 }
        },
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
        side: THREE.DoubleSide,
        shading: THREE.FlatShading

    } );

    //  material.uniforms.noiseMap.value.wrapS = material.uniforms.noiseMap.value.wrapT = THREE.RepeatWrapping;
    //  material.uniforms.heightMap.value.wrapS = material.uniforms.heightMap.value.wrapT = THREE.RepeatWrapping;

    mesh = new THREE.Mesh( 
        geometry, 
        material
    );

    scene.add( mesh );
    meshes.push( mesh );

    console.log( ( width * height ) + ' cubes' )

    window.addEventListener( 'resize', onWindowResized );
    onWindowResized();
/*
    vignettePass = new WAGNER.Vignette2Pass();
    vignettePass.params.reduction = 3;
    FXAAPass = new WAGNER.FXAAPass();
    blurPass = new WAGNER.FullBoxBlurPass();
    blendPass = new WAGNER.BlendPass();
    blendPass.params.mode = WAGNER.BlendMode.Multiply;
    bloomPass = new WAGNER.MultiPassBloomPass();
    bloomPass.params.blurAmount = 5;
    //bloomPass.params.applyZoomBlur = true;
    bloomPass.params.zoomBlurStrength = .2;
*/
    controls = new THREE.OrbitControls( camera, renderer.domElement );

    controls.minDistance = 2;
    controls.maxDistance = 2000;
    controls.autoRotate = false;
    controls.noPan = false;


    animate();

}

function showMessage( msg ) {

    message.textContent = msg;

}

function onWindowResized( event ) {
    
    renderer.setSize( container.clientWidth, container.clientHeight );
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    //composer.setSize( renderer.domElement.width, renderer.domElement.height );
    /*var AOScale = 1;
    AOComposer.setSize( AOScale * renderer.domElement.width, AOScale * renderer.domElement.height );*/
    
}

function animate() {

    //controls.update();

    requestAnimationFrame( animate );
    render();

}

var tmpVector = new THREE.Vector3( 0, 0, 0);

function render() {
    
    if( loaded ) {

        /*if( conwayPass.isLoaded() ) {
            composer.setSource( texture );
            composer.pass( conwayPass );
        }*/

        //mesh.material.uniforms.map.value = composer.output;
        meshes.forEach( function( mesh ) {
            mesh.material.uniforms.time.value += .1;
        } );

        renderer.render( scene, camera );

    }

}

</script>
    
    </body>
</html>